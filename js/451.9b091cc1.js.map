{"version":3,"file":"js/451.9b091cc1.js","mappings":"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","sources":["webpack://novatool_claude/./src/components/BinaryViewer.vue","webpack://novatool_claude/./src/components/BinaryViewer.vue?3df4"],"sourcesContent":["<template>  \n  <div class=\"binary-viewer\">\n    <!-- <h2>Binary file viewer</h2> -->\n    <div class=\"viewer-container\">\n      <!-- 파일 선택 영역 -->\n      <div class=\"file-section\">\n        <!-- <input type=\"file\" @change=\"onFileSelect\" ref=\"fileInput\" style=\"display: none\">\n        <button @click=\"fileInput.click()\" class=\"primary-btn\">Select File</button> -->\n        <div class=\"file-input-container\">\n          <label class=\"import-btn\">\n            <input type=\"file\" accept=\"*/*\" @change=\"onFileSelect\" class=\"file-input\">\n            <span class=\"material-icons\">file_open</span>\n            Open File\n          </label>\n          <span class=\"file-info\">\n            {{ fileName ? `${fileName} (${fileSize})` : \"Intel HEX file automatically convert\" }}\n          </span>\n        </div>\n        \n        <!-- 인텔 헥사 파일인 경우에만 Export BIN 버튼 표시 -->     \n        <div class=\"file-export-container\">\n          <label class=\"export-btn\" v-if=\"isHexFile && hexData\">\n            <input  @click=\"exportBinary\" class=\"file-input\">\n            <span class=\"material-icons\">file_download</span> \n            Export BIN\n          </label>\n        </div>\n        \n      </div>\n\n      <!-- 파일 형식 선택 -->\n      <div class=\"format-section\" v-if=\"isHexFile\">\n        <label>\n          <input type=\"radio\" v-model=\"fileFormat\" value=\"binary\"> Binary\n        </label>\n        <label>\n          <input type=\"radio\" v-model=\"fileFormat\" value=\"hex\"> Intel HEX\n        </label>\n      </div>\n\n      <!-- 로딩 표시 -->\n      <div v-if=\"isLoading\" class=\"loading-section\">\n        <div class=\"progress-bar\">\n          <div class=\"progress\" :style=\"{ width: `${progress}%` }\"></div>\n        </div>\n        <span>File loading... {{ progress }}%</span>\n      </div>\n\n      <!-- 컨트롤 영역 -->\n      <div v-if=\"fileContent\" class=\"control-section\">\n        <div class=\"left-controls\">\n          <label>\n            <input type=\"checkbox\" v-model=\"showAscii\"> Show ASCII\n          </label>\n          <label>\n            <span style=\"padding-right: 10px;\">Bytes/Line</span>\n            <select  v-model=\"bytesPerLine\">\n              <option :value=\"8\">8</option>\n              <option :value=\"16\">16</option>\n              <!-- <option :value=\"32\">32</option> -->\n            </select>\n          </label>\n        </div>\n        <div class=\"right-controls\">\n          <!-- <input \n            type=\"text\" \n            v-model=\"searchText\"\n            placeholder=\"16진수 검색 (예: FF 00)\"\n            class=\"search-input\"\n            @keyup.enter=\"search\"\n          > \n          <button @click=\"search\" class=\"primary-btn\">검색</button>-->\n        </div>\n      </div>\n\n      <!-- 16진수 표시 영역 -->\n      <div v-if=\"fileContent\" class=\"hex-view\" ref=\"hexView\">\n        <div class=\"hex-content\" :style=\"{ height: `${totalHeight}px` }\">\n          <div \n            class=\"viewport\" \n            :style=\"{ transform: `translateY(${scrollOffset}px)` }\"\n          >\n            <div \n              v-for=\"line in visibleLines\" \n              :key=\"line.index\"\n              class=\"hex-line\"\n            >\n              <!-- 주소 -->\n              <div class=\"address\">{{ formatAddress(line.offset) }}</div>\n              \n              <!-- 16진수 값 -->\n              <div class=\"hex-values\">\n                <span \n                  v-for=\"(byte, byteIndex) in line.bytes\" \n                  :key=\"byteIndex\"\n                  :class=\"[\n                    'hex-byte', \n                    { \n                      highlighted: isHighlighted(line.offset + byteIndex),\n                      selected: isSelected(line.offset + byteIndex)\n                    }\n                  ]\"\n                  @click=\"selectByte(line.offset + byteIndex)\"\n                >{{ formatByte(byte) }}</span>\n              </div>\n              \n              <!-- ASCII 값 -->\n              <div v-if=\"showAscii\" class=\"ascii-values\">\n                <span \n                  v-for=\"(byte, byteIndex) in line.bytes\" \n                  :key=\"byteIndex\"\n                  :class=\"{ \n                    highlighted: isHighlighted(line.offset + byteIndex),\n                    selected: isSelected(line.offset + byteIndex)\n                  }\"\n                  @click=\"selectByte(line.offset + byteIndex)\"\n                >{{ toAscii(byte) }}</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted, onUnmounted, nextTick, watch } from 'vue'\n\n// 상수\nconst CHUNK_SIZE = 1024 * 1024 // 1MB\nconst LINE_HEIGHT = 16 // 20px에서 16px로 줄임\nconst CACHE_SIZE = 10 * 1024 * 1024 // 10MB 캐시 크기\n\n// refs\nconst hexView = ref(null)\nconst fileContent = ref(null)\nconst fileName = ref('')\nconst fileSize = ref('')\nconst isLoading = ref(false)\nconst progress = ref(0)\nconst showAscii = ref(true)\nconst bytesPerLine = ref(16)\nconst highlightedBytes = ref(new Set())\nconst startLine = ref(0)\nconst selectedFile = ref(null)\nconst chunksCache = ref(new Map()) // 청크 캐시\nconst visibleLinesData = ref([])\nconst selectedByte = ref(null)\nconst fileFormat = ref('binary') // 'binary' 또는 'hex'\nconst hexData = ref(null) // 인텔 헥사 파일 데이터를 저장\nconst isHexFile = ref(false)\n\n// 계산된 속성\nconst visibleLines = computed(() => {\n  return visibleLinesData.value\n})\n\nconst totalLines = computed(() => {\n  if (!selectedFile.value && !hexData.value) return 0\n  \n  if (fileFormat.value === 'hex' && hexData.value) {\n    const fullLines = Math.floor(hexData.value.length / bytesPerLine.value)\n    const hasRemainder = hexData.value.length % bytesPerLine.value > 0\n    return fullLines + (hasRemainder ? 1 : 0)\n  }\n  \n  const fullLines = Math.floor(selectedFile.value.size / bytesPerLine.value)\n  const hasRemainder = selectedFile.value.size % bytesPerLine.value > 0\n  return fullLines + (hasRemainder ? 1 : 0)\n})\n\nconst totalHeight = computed(() => {\n  return totalLines.value * LINE_HEIGHT\n})\n\nconst scrollOffset = computed(() => {\n  return Math.max(0, startLine.value) * LINE_HEIGHT\n})\n\n// 메서드\nconst formatAddress = (offset) => offset.toString(16).padStart(8, '0').toUpperCase()\nconst formatByte = (byte) => {\n  if (byte === undefined) return '  '\n  return byte.toString(16).padStart(2, '0').toUpperCase()\n}\n\nconst toAscii = (byte) => {\n  if (byte === undefined) return ' '\n  return byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'\n}\nconst isHighlighted = (index) => highlightedBytes.value.has(index)\n\nconst formatFileSize = (bytes) => {\n  const units = ['B', 'KB', 'MB', 'GB']\n  let size = bytes\n  let unitIndex = 0\n  \n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024\n    unitIndex++\n  }\n  \n  return `${size.toFixed(1)} ${units[unitIndex]}`\n}\n\n// 인텔 헥사 파일 파싱 함수\nconst parseIntelHex = (text) => {\n  const lines = text.split(/\\r?\\n/).filter(line => line.trim().length > 0)\n  const memory = new Uint8Array(16 * 1024 * 1024) // 16MB 메모리 공간 할당\n  let maxAddress = 0\n  let baseAddress = 0\n  \n  for (const line of lines) {\n    if (line[0] !== ':') continue // 인텔 헥사 라인은 항상 ':'로 시작\n    \n    const byteCount = parseInt(line.substr(1, 2), 16)\n    const address = parseInt(line.substr(3, 4), 16)\n    const recordType = parseInt(line.substr(7, 2), 16)\n    \n    // 레코드 타입에 따른 처리\n    switch (recordType) {\n      case 0: // 데이터 레코드\n        for (let i = 0; i < byteCount; i++) {\n          const byte = parseInt(line.substr(9 + i * 2, 2), 16)\n          const absoluteAddress = baseAddress + address + i\n          memory[absoluteAddress] = byte\n          maxAddress = Math.max(maxAddress, absoluteAddress)\n        }\n        break\n      case 1: // 파일 끝 레코드\n        break\n      case 2: // 확장 세그먼트 주소 레코드\n        baseAddress = parseInt(line.substr(9, 4), 16) * 16\n        break\n      case 4: // 확장 선형 주소 레코드\n        baseAddress = parseInt(line.substr(9, 4), 16) * 65536\n        break\n      // 다른 레코드 타입은 필요에 따라 추가\n    }\n  }\n  \n  // 실제 사용된 메모리만 반환\n  return memory.slice(0, maxAddress + 1)\n}\n\n// 바이너리 파일로 내보내기 함수\nconst exportBinary = () => {\n  if (!hexData.value) return\n  \n  // Uint8Array를 Blob으로 변환\n  const blob = new Blob([hexData.value], { type: 'application/octet-stream' })\n  \n  // 다운로드 링크 생성\n  const url = URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  \n  // 원본 파일 이름에서 .hex를 제거하고 .bin 확장자 추가\n  const originalName = fileName.value\n  const baseName = originalName.toLowerCase().endsWith('.hex') \n    ? originalName.slice(0, -4) \n    : originalName\n  \n  a.download = `${baseName}.bin`\n  \n  // 링크 클릭하여 다운로드 시작\n  document.body.appendChild(a)\n  a.click()\n  \n  // 정리\n  setTimeout(() => {\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n  }, 0)\n}\n\nconst loadLinesRange = async (start, end) => {\n  const lines = []\n  \n  if (fileFormat.value === 'hex' && hexData.value) {\n    // 인텔 헥사 데이터 처리\n    //const startOffset = start * bytesPerLine.value\n    //const endOffset = Math.min(end * bytesPerLine.value, hexData.value.length)\n    \n    for (let i = start; i < end; i++) {\n      const offset = i * bytesPerLine.value\n      if (offset >= hexData.value.length) break\n      \n      const remainingBytes = hexData.value.length - offset\n      const lineLength = Math.min(bytesPerLine.value, remainingBytes)\n      const bytes = Array.from(hexData.value.slice(offset, offset + lineLength))\n      \n      lines.push({\n        index: i,\n        offset,\n        bytes\n      })\n    }\n  } else {\n    // 기존 바이너리 파일 처리\n    const startOffset = start * bytesPerLine.value\n    const endOffset = Math.min(end * bytesPerLine.value, selectedFile.value.size)\n    \n    // 필요한 청크들을 로드\n    await ensureChunksLoaded(startOffset, endOffset)\n    \n    // 마지막 라인 번호 계산\n    const fullLines = Math.floor(selectedFile.value.size / bytesPerLine.value)\n    const hasRemainder = selectedFile.value.size % bytesPerLine.value > 0\n    const lastLine = fullLines + (hasRemainder ? 0 : -1)\n    \n    for (let i = start; i <= lastLine && i < end; i++) {\n      const offset = i * bytesPerLine.value\n      if (offset >= selectedFile.value.size) break\n      \n      const remainingBytes = selectedFile.value.size - offset\n      const lineLength = Math.min(bytesPerLine.value, remainingBytes)\n      const bytes = await getBytes(offset, lineLength)\n      \n      lines.push({\n        index: i,\n        offset,\n        bytes\n      })\n    }\n  }\n  \n  return lines\n}\n\n\nconst getChunkKey = (offset) => {\n  return Math.floor(offset / CHUNK_SIZE) * CHUNK_SIZE\n}\n\nconst ensureChunksLoaded = async (startOffset, endOffset) => {\n  const startChunk = getChunkKey(startOffset)\n  const endChunk = getChunkKey(endOffset)\n  \n  for (let offset = startChunk; offset <= endChunk; offset += CHUNK_SIZE) {\n    if (!chunksCache.value.has(offset)) {\n      await loadChunk(offset)\n    }\n  }\n  \n  // 캐시 크기 관리\n  while (getCacheSize() > CACHE_SIZE) {\n    const oldestKey = chunksCache.value.keys().next().value\n    chunksCache.value.delete(oldestKey)\n  }\n}\n\nconst getCacheSize = () => {\n  let size = 0\n  for (const chunk of chunksCache.value.values()) {\n    size += chunk.length\n  }\n  return size\n}\n\nconst loadChunk = async (offset) => {\n  const chunk = selectedFile.value.slice(\n    offset,\n    Math.min(offset + CHUNK_SIZE, selectedFile.value.size)\n  )\n  const buffer = await readChunk(chunk)\n  chunksCache.value.set(offset, new Uint8Array(buffer))\n}\n\nconst getBytes = async (offset, length) => {\n  const chunkOffset = getChunkKey(offset)\n  const chunk = chunksCache.value.get(chunkOffset)\n  if (!chunk) return new Array(length).fill(undefined)\n  \n  const relativeOffset = offset - chunkOffset\n  const bytes = chunk.slice(relativeOffset, relativeOffset + length)\n  \n  // 파일 끝을 넘어가는 부분은 제거\n  if (offset + bytes.length > selectedFile.value.size) {\n    bytes.length = selectedFile.value.size - offset\n  }\n  \n  return Array.from(bytes)\n}\n\nconst onFileSelect = async (event) => {\n  const file = event.target.files[0]\n  if (!file) return\n  \n  fileName.value = file.name\n  fileSize.value = formatFileSize(file.size)\n  selectedFile.value = file\n  chunksCache.value.clear()\n  startLine.value = 0\n  isLoading.value = true\n  progress.value = 0\n  \n  // 파일 확장자가 .hex인지 확인\n  isHexFile.value = file.name.toLowerCase().endsWith('.hex')\n  \n  // 인텔 헥사 파일이 아니면 바이너리 모드로 고정\n  if (!isHexFile.value) {\n    fileFormat.value = 'binary'\n  } else {\n    // 인텔 헥사 파일이면 기본적으로 hex 모드로 설정\n    fileFormat.value = 'hex'\n    try {\n      // 인텔 헥사 파일 처리\n      const text = await readTextFile(file)\n      hexData.value = parseIntelHex(text)\n      fileSize.value = formatFileSize(hexData.value.length)\n    } catch (error) {\n      console.error('인텔 헥사 파일 파싱 오류:', error)\n      // 파싱 실패 시에도 format-section은 계속 표시\n    }\n  }\n  \n  try {\n    fileContent.value = true // 먼저 뷰어를 표시\n    await nextTick()\n    \n    // 스크롤 이벤트 핸들러 등록\n    if (hexView.value) {\n      console.debug('Registering scroll event handler')\n      hexView.value.addEventListener('scroll', handleScroll)\n    }\n    \n    // 초기 데이터 로드\n    await updateVisibleLines()\n  } catch (error) {\n    console.error('파일 로딩 오류:', error)\n  } finally {\n    isLoading.value = false\n  }\n}\n\nconst readTextFile = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = e => resolve(e.target.result)\n    reader.onerror = reject\n    reader.readAsText(file)\n  })\n}\n\nconst readChunk = (chunk) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = e => resolve(e.target.result)\n    reader.onerror = reject\n    reader.readAsArrayBuffer(chunk)\n    //console.debug('readChunk:', reader.length)\n  })\n}\n\n// const search = () => {\n//   const query = searchText.value.trim()\n//   if (!query || !fileContent.value) return\n  \n//   highlightedBytes.value.clear()\n  \n//   const searchBytes = query\n//     .replace(/\\s+/g, '')\n//     .match(/.{1,2}/g)\n//     ?.map(hex => parseInt(hex, 16))\n  \n//   if (!searchBytes) return\n  \n//   for (let i = 0; i < fileContent.value.length - searchBytes.length + 1; i++) {\n//     if (searchBytes.every((byte, j) => fileContent.value[i + j] === byte)) {\n//       for (let j = 0; j < searchBytes.length; j++) {\n//         highlightedBytes.value.add(i + j)\n//       }\n//     }\n//   }\n// }\n\nconst updateVisibleLines = async () => {\n  if (!selectedFile.value) return\n  \n  const containerHeight = hexView.value?.clientHeight || 0\n  const visibleCount = Math.ceil(containerHeight / LINE_HEIGHT) + 10 // 버퍼 증가\n  const start = Math.max(0, startLine.value - 5)\n  const end = Math.min(totalLines.value, startLine.value + visibleCount + 5)\n  \n  //console.debug('Updating visible lines:', start, '->', end)\n  const lines = await loadLinesRange(start, end)\n  visibleLinesData.value = lines\n}\n\nconst handleScroll = () => {\n  if (!hexView.value || !selectedFile.value) return\n  \n  const newStartLine = Math.floor(hexView.value.scrollTop / LINE_HEIGHT)\n  if (newStartLine !== startLine.value) {\n    startLine.value = newStartLine\n    updateVisibleLines()\n  }\n}\n\nconst selectByte = (index) => {\n  selectedByte.value = selectedByte.value === index ? null : index\n}\n\nconst isSelected = (index) => selectedByte.value === index\n\n// bytesPerLine watch 추가\nwatch(fileFormat, async (newValue) => {\n  if (selectedFile.value && isHexFile.value) {\n    if (newValue === 'hex' && !hexData.value) {\n      isLoading.value = true\n      try {\n        const text = await readTextFile(selectedFile.value)\n        hexData.value = parseIntelHex(text)\n        fileSize.value = formatFileSize(hexData.value.length)\n      } catch (error) {\n        console.error('인텔 헥사 파일 파싱 오류:', error)\n      } finally {\n        isLoading.value = false\n      }\n    }\n    updateVisibleLines()\n  }\n})\n\nwatch(bytesPerLine, (newValue) => {\n  document.documentElement.style.setProperty('--bytes-per-line', newValue.toString())\n  // 바이트 수가 변경되면 보이는 라인을 업데이트\n  updateVisibleLines()\n}, { immediate: true })\n\n// 라이프사이클 훅\nonMounted(() => {\n  console.debug('Component mounted')\n})\n\nonUnmounted(() => {\n  if (hexView.value) {\n    console.debug('Removing scroll event handler')\n    hexView.value.removeEventListener('scroll', handleScroll)\n  }\n})\n</script>\n\n<style scoped>\n.format-section {\n  display: flex;\n  gap: 16px;\n  padding: 8px 12px;\n  background: #f5f1ea;\n  border-radius: 6px;\n  margin-bottom: 8px;\n}\n\n.format-section label {\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  cursor: pointer; \n}\n\n.binary-viewer {\n  padding: 20px;\n  height: 100%;\n  background: #fff;\n  border-radius: 8px;\n  box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n}\n\n.viewer-container {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  height: calc(100% - 40px);\n}\n\n\n.file-info {\n  color: #666;\n  font-size: 0.9em;\n}\n\n.control-section {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  background: #f5f1ea;\n  padding: 12px;\n  border-radius: 6px;\n}\n\n.file-section {\n  display: flex;\n  justify-content: space-between; /* 좌우 정렬 */\n  align-items: center;\n  width: 100%;\n  margin-bottom: 12px;\n}\n\n.file-input-container {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n\n.file-export-container {\n  margin-left: auto; /* 오른쪽 정렬 */\n}\n\n.left-controls, .right-controls {\n  display: flex;\n  gap: 16px;\n  align-items: center;\n}\n\n.search-input {\n  width: 200px;\n  padding: 6px 12px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n}\n\n.hex-view {\n  flex-grow: 1;\n  overflow-y: scroll;\n  border: 1px solid #e8e1d9;\n  border-radius: 6px;\n  background: #faf7f2;\n  font-family: monospace;\n  position: relative;\n  height: 600px;\n  will-change: transform; /* 성능 최적화 */\n}\n\n.hex-content {\n  position: relative;\n  width: 100%;\n  will-change: transform; /* 성능 최적화 */\n}\n\n.viewport {\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  will-change: transform; /* 성능 최적화 */\n}\n\n.hex-line {\n  display: flex;\n  padding: 2px 4px;\n  height: 20px;\n  align-items: center;\n  gap: 12px;\n}\n\n.hex-line:hover {\n  background: rgba(0,0,0,0.03);\n}\n\n.address {\n  color: #6b5b95;\n  width: 80px;\n  flex-shrink: 0;\n  padding-left: 4px;\n  border-right: 1px solid #e8e1d9;\n}\n\n.hex-values {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, 18px);\n  gap: 3px;\n  margin-right: 16px;\n  width: calc((18px + 3px) * var(--bytes-per-line, 16) - 3px);\n  padding: 0 8px;\n  border-right: 1px solid #e8e1d9;\n  background: rgba(107, 91, 149, 0.03);\n} \n\n.hex-byte {\n  color: #3c4f76;\n  width: 18px;\n  text-align: center;\n  cursor: pointer;\n  user-select: none;\n}\n\n.hex-byte:hover {\n  background: rgba(60, 79, 118, 0.1);\n  border-radius: 2px;\n}\n\n.hex-byte.selected,\n.ascii-values span.selected {\n  background: #4a90e2;\n  color: white;\n  border-radius: 2px;\n}\n\n.ascii-values span {\n  user-select: none;\n  cursor: pointer;\n}\n\n.ascii-values span:hover {\n  background: rgba(68, 102, 68, 0.1);\n  border-radius: 2px;\n}\n\n.loading-section {\n  text-align: center;\n  padding: 20px;\n}\n\n.progress-bar {\n  width: 100%;\n  height: 4px;\n  background: #eee;\n  border-radius: 2px;\n  overflow: hidden;\n  margin-bottom: 8px;\n}\n\n.progress {\n  height: 100%;\n  background: #8b7355;\n  transition: width 0.3s ease;\n}\n\n.primary-btn {\n  background: #8b7355;\n  color: white;\n  border: none;\n  padding: 8px 16px;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.primary-btn:hover {\n  background: #9c8465;\n}\n\n.import-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: 6px;\n  padding: 8px 16px;\n  background-color: #4CAF50;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  font-size: 14px;\n  transition: background-color 0.2s;\n}\n\n.import-btn:hover {\n  background-color: #45a049;\n}\n\n.import-btn .material-icons {\n  font-size: 18px;\n}\n\n.export-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: 6px;\n  background: #2196F3; /* Material Blue 500 */\n  color: white;\n  border: none;\n  padding: 8px 16px;\n  border-radius: 4px;\n  cursor: pointer;\n  font-size: 14px;\n  transition: background 0.2s, box-shadow 0.2s;\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}\n\n.export-btn:hover {\n  background: #1976D2; /* Material Blue 700 */\n  box-shadow: 0 3px 6px rgba(0,0,0,0.15);\n}\n\n.export-btn .material-icons {\n  font-size: 18px;\n}\n\n.file-input {\n  display: none;\n}\n\nselect {\n  padding: 4px 8px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n}\n\n@media screen and (max-width: 768px) {\n  .binary-viewer {\n    padding: 10px;\n  }\n\n  .hex-line {\n    flex-wrap: wrap;\n    height: auto;\n    padding: 4px 2px;\n    gap: 6px;\n  }\n\n  .address {\n    width: 100%;\n    border-right: none;\n    border-bottom: 1px solid #e8e1d9;\n    padding-bottom: 4px;\n    margin-bottom: 4px;\n    text-align: left;\n  }\n\n  .hex-values {\n    display: flex;\n    flex-wrap: wrap;\n    width: 100%;\n    gap: 2px;\n    margin-right: 0;\n    padding: 4px 0;\n    border-right: none;\n    border-bottom: 1px solid #e8e1d9;\n    justify-content: flex-start;\n  }\n\n  .hex-byte {\n    width: calc((100% - (2px * (var(--bytes-per-line, 16) - 1))) / var(--bytes-per-line, 16));\n    flex-grow: 1;\n    text-align: center;\n  }\n\n  .ascii-values {\n    display: flex;\n    flex-wrap: wrap;\n    width: 100%;\n    gap: 2px;\n    justify-content: flex-start;\n  }\n\n  .ascii-values span {\n    width: calc((100% - (2px * (var(--bytes-per-line, 16) - 1))) / var(--bytes-per-line, 16));\n    text-align: center;\n    flex-grow: 1;\n  }\n\n  .hex-view {\n    height: 400px; /* 모바일에서 높이 조정 */\n  }\n\n  .control-section {\n    flex-direction: column;\n    align-items: stretch;\n    gap: 10px;\n  }\n\n  .left-controls, .right-controls {\n    flex-direction: column;\n    align-items: stretch;\n  }\n\n  select, .search-input {\n    width: 100%;\n  }\n}\n</style>","import script from \"./BinaryViewer.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./BinaryViewer.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./BinaryViewer.vue?vue&type=style&index=0&id=ab27bf62&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-ab27bf62\"]])\n\nexport default __exports__"],"names":["CHUNK_SIZE","LINE_HEIGHT","CACHE_SIZE","hexView","ref","fileContent","fileName","fileSize","isLoading","progress","showAscii","bytesPerLine","highlightedBytes","Set","startLine","selectedFile","chunksCache","Map","visibleLinesData","selectedByte","fileFormat","hexData","isHexFile","visibleLines","computed","value","totalLines","fullLines","Math","floor","length","hasRemainder","size","totalHeight","scrollOffset","max","formatAddress","offset","toString","padStart","toUpperCase","formatByte","byte","undefined","toAscii","String","fromCharCode","isHighlighted","index","has","formatFileSize","bytes","units","unitIndex","toFixed","parseIntelHex","text","lines","split","filter","line","trim","memory","Uint8Array","maxAddress","baseAddress","byteCount","parseInt","substr","address","recordType","i","absoluteAddress","slice","exportBinary","blob","Blob","type","url","URL","createObjectURL","a","document","createElement","href","originalName","baseName","toLowerCase","endsWith","download","body","appendChild","click","setTimeout","removeChild","revokeObjectURL","loadLinesRange","async","start","end","remainingBytes","lineLength","min","Array","from","push","startOffset","endOffset","ensureChunksLoaded","lastLine","getBytes","getChunkKey","startChunk","endChunk","loadChunk","getCacheSize","oldestKey","keys","next","delete","chunk","values","buffer","readChunk","set","chunkOffset","get","fill","relativeOffset","onFileSelect","file","event","target","files","name","clear","readTextFile","error","console","nextTick","debug","addEventListener","handleScroll","updateVisibleLines","Promise","resolve","reject","reader","FileReader","onload","e","result","onerror","readAsText","readAsArrayBuffer","containerHeight","clientHeight","visibleCount","ceil","newStartLine","scrollTop","selectByte","isSelected","watch","newValue","documentElement","style","setProperty","immediate","onMounted","onUnmounted","removeEventListener","__exports__"],"sourceRoot":""}